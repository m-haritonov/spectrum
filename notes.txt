TODO: change architecture from "first build all, then run all" to "build and run, build and run, etc.", change context feature, add combination feature, replace group and test constructs to spec ..., replace ContextModifiers class to Befores and Afters classes

TODO: test('', array(
	array('name', 'name', 'name),
	array('value', 'value', 'value'),
	array('value', 'value', 'value'),
	array('value', 'value', 'value'),
	array('value', 'value', 'value'),
), function(){}); ???

TODO: array context group:
	group('aaa', array(
		'Номер мегафон' => array('code' => '495', 'phone' => '35861923'),
		'group: Межгород' => array(
			'Номер мегафон' => array('code' => '495', 'phone' => '35861923'),
			'Номер МТС' => array('code' => '495', 'phone' => '35861923'),
		),
	), function(){
		test('bbb', function(){});
	});
	
TODO: change context declaration style???
	// from:
	group('', function(){}, function(){});
	
	// to:
	contexts(function(){});
	group('', function(){});
	
	
	
	// from:
	test('', function(){}, function(){});
	
	// to:
	group(function(){
		contexts(function(){});
		test('', function(){});
	});
	
	
	
	// from:
	test('', array(
		array('aaa' => 'bbb'),
		array('aaa' => 'bbb'),
		array('aaa' => 'bbb'),
		array('aaa' => 'bbb'),
	), function(){});
	
	// to:
	group(function(){
		contexts(array(
			array('aaa' => 'bbb'),
			array('aaa' => 'bbb'),
			array('aaa' => 'bbb'),
			array('aaa' => 'bbb'),
		), $addType = null);
		
		// Values: null, "up/wrap", "down/inject", "next"
		// When $addType is "up", then specs is bound to contexts as children (to all descendant ending contexts)
		// When $addType is "down", then contexts is bound to specs as children (to all descendant ending specs)
		// When $addType is "next", then contexts is bound to next spec as children (to all descendant ending specs)
		// When $addType is null, then:
		// When there are many specs in group, then uses "up" type
		// When there is one spec in group, then uses "down" type
		test('', function(){});
	});
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
spec('aaa', function() {
	be(8)->eq('8');
	
	before(function() {
		data()->aaa = 1;
	});
	
	spec('bbb', function() {
		be(8)->eq('8');
	});
	
	spec('ccc', function() {
		be(8)->eq('8');
	});
})




spec('MySql', function() {
	before(function() {
		data()->aaa = 'MySql';
	});
	
	spec('MyClass', function() {})
})

spec('Files', function() {
	before(function() {
		data()->aaa = 'files';
	});
	
	spec('MyClass', function() {})
})


combine(function(){ spec('MySql'); spec('Files'); }, function(){ spec('MyClass'); });


spec('SomeStorage', function() {
	spec('MySql', function() {
		before(function() {
			data()->aaa = 'MySql';
		});
	});
	
	spec('Files', function() {
		before(function() {
			data()->aaa = 'files';
		});
	});
}, function() {
	spec('MyClass', function() {})
});


spec('SomeStorage', array(
	function() {
		spec('MySql', function() {
			before(function() {
				data()->aaa = 'MySql';
			});
		});
		
		spec('Files', function() {
			before(function() {
				data()->aaa = 'files';
			});
		});
	},
	function() {
		spec('MyClass', function() {})
	}
));



spec('someProject', function() {
	spec('someFunction', array(
		'aaa' => array(1, 2, 3),
		'bbb' => function() { return array(); },
		'ccc' => array(1, 2, 3),
	), function() {
		spec('ccc = 1', function() {
			before(function() {
				data()->ccc = 1;
			});
		});
	}, function() {
		be(\someProject\someFunction('aaa'))->ident('bbb');
	});
});


spec('someProject', function() {
	spec('someFunction', array(
		'aaa' => array(1, 2, 3),
		'bbb' => function() { return array(); },
		'ccc' => array(1, 2, 3),
	), function() {
		be(\someProject\someFunction('aaa'))->ident('bbb');
	});
});

spec('someProject', function() {
	spec('someFunction', [
		'aaa' => array(1, 2, 3),
		'ccc' => array(1, 2, 3),
		array(
			array('priceInt' => 1, 'expectedPriceInt' => 1),
			array('priceInt' => 10, 'expectedPriceInt' => 10),
			array('priceInt' => 1000, 'expectedPriceInt' => '1 000'),
		),
		array(
			array('priceFraction' => '.0', 'expectedPriceFraction' => '.00'),
			array('priceFraction' => '.00', 'expectedPriceFraction' => '.00'),
			array('priceFraction' => '.1000', 'expectedPriceFraction' => '.10'),
		),
		function() {
			message(data()->expectedPriceInt . data()->expectedPriceFraction); // If you want see that you generate correct expected price
			be(\currency\formatPrice(data()->priceInt . data()->priceFraction))->ident(data()->expectedPriceInt . data()->expectedPriceFraction);
		},
		function() {
			be(\currency\formatPrice('aaa'))->ident('bbb');
		}
	]);
});




spec('someProject', function() {
	spec('someFunction', array(
		function() {
			spec('aaaaaaa', function() {
				before(function() {
					data()->a = 1;
					data()->b = 1;
					data()->c = 1;
				});
			});
			
			spec('aaaaaaa', function() {
				before(function() {
					data()->a = 2;
					data()->b = 2;
					data()->c = 2;
				});
			});
		},
		function() {
			spec('aaaaaaa', function() {
				before(function() {
					data()->a = 1;
					data()->b = 1;
					data()->c = 1;
				});
			});
			
			spec('aaaaaaa', function() {
				before(function() {
					data()->a = 2;
					data()->b = 2;
					data()->c = 2;
				});
			});
		},
		function() {
			spec('aaaaaaa', function() {
				before(function() {
					data()->a = 1;
					data()->b = 1;
					data()->c = 1;
				});
				
				spec('aaaaaaa', function() {
					before(function() {
						data()->a = 1;
						data()->b = 1;
						data()->c = 1;
					});
				});
			});
			
			spec('aaaaaaa', function() {
				before(function() {
					data()->a = 2;
					data()->b = 2;
					data()->c = 2;
				});
			});
		},
		function() {
			be(\someProject\someFunction('aaa'))->ident('bbb');
		},
		function() {
			be(\someProject\someFunction('aaa'))->ident('bbb');
		}
	));
});























spec('aaa', function() {
	spec('1', function(){
		before(function() {
			data()->aaa = 1;
		});
	});
	
	spec('2', function(){
		before(function() {
			data()->aaa = 2;
		});
	});
}, function() {
	
	be->eq('8');
	
	before(function() {
		data()->qwe = 12;
	});
	
	after(function() {
		data()->qwe = 12;
	});
	
	spec('', function() {});
})
	

combine(function(){ spec('MySql'); spec('Files'); }, function(){ spec('MyClass'); });
combine(function(){ spec('MySql'); }, function(){ spec('MyClass'); spec('MyClass'); spec('MyClass'); spec('MyClass'); });


TODO:
		combine(array('aaa' => array(1, 2, 3), function(){ spec(); spec(); }))
		1
			4
				7
				8
				9
			5
				7
				8
				9
			6
				7
				8
				9
		2
			4
				7
				8
				9
			5
				7
				8
				9
			6
				7
				8
				9
		3
			4
				7
				8
				9
			5
				7
				8
				9
			6
				7
				8
				9
		
TODO: _private/registry
TODO: throw exception if before/after is called after spec
TODO: be()->eq() vs be()->equals(), be()->ident() vs be()->idents()	
TODO: Assertion -> Be
TODO: ContextModifiers -> Befores, Afters
TODO: Assertion -> Be
TODO: setBreakOnFirstUserFail
TODO: pattern('aaa', function($a, $b) {}), pattern('aaa', array($a, $b))
TODO: onSpecCallStart, onSpecCallFinish, onBeforeCallStart, onBeforeCallFinish, onAfterCallStart, onAfterCallFinish, onBeCallStart, onBeCallFinish, ...
TODO: move notes.txt content to README.md "Development notes" section
TODO: определить минимальную версию PHP. Пока это 5.3.9 из-за is_a
TODO: fix reports in all browsers
TODO: \spectrum\run должен возвращать строку вместо bool/null?
TODO: удалить unknown, в драйверах вместо задания unknown выбрасывать исключение
TODO: function -> callback
TODO: remove vs removeAll
TODO: improve FunctionType

TODO: ContextModifiers::addBefore(), addAfter???
TODO: matchers - вместо передачи details передавать значения по ссылке
TODO: hasRegisteredEventListener -> hasEventListener, unregisterEventListeners -> removeEventListeners, registerEventListener -> addEventListener

TODO: config::enableReports()
TODO: setReportsClass(class), \core\ReportsInterface, Spec::getReports
TODO: добавить doc комментарии для поддержки рефакторинга

TODO: doc: you can create own functions like describe/it
TODO: doc: you can use be() in contexts and matchers
TODO: doc: extension/package use init.php, put private files to _private directory

TODO: писать ключ (key => value) в getArrayWithContextsElementTitle
TODO: обрезать параметры функции при выводе в reports

TODO: config for group:
	group(function() {
		config::setOutputNewline();
		config::setBreakOnFirstPhpError();
	});
	
	Spec::getConfig()
	
	
	


TODO: be()->throwsException vs be()->throws() vs be()->throwing() vs be()->throw()
TODO: create be()->triggersError/triggers/error($errorType = null, $errorMessage = null)  ???
TODO: create settings.captureOutput/Print (плюс вывод в отчёте в отдельном блоке с заголовком "Output from test:" с визуализацией пробельных символов)
TODO: create settings.backupGlobalVariables ???
TODO: be(function(){})->outputs/prints('aaa a aaaaa ');

TODO: рядом с результатом (серым шрифтом) и в верхнем и нижнем блоке писать кол-во выполненных тестов, время выполнения каждого теста и группы тестов (время выполнения группы вычислять либо путём сложения времени детей либо замерять реальное время выполнения либо писать оба значения либо одно значение писать в title)
TODO: проработать тексты сообщений в исключениях (возможно, привести к единому формату вида "function/method name: message")
TODO: исправить грамматические ошибки в названиях классов, методов и функций, в сообщениях исключений, в тексте отчётов и т.п.
TODO: set breakOnFirstMatcherFail to true by default
TODO: add tests for charset usages








TODO: добавить возможность перевода??? Пример: 
	test('Makes something', function(){}, function(){
	}, array(
		'translations/langs' => array(
			'ru' => 'Делает что-либо',
		)
	));
	
	или:
	translate('Делает что-либо', 'ru');
	it('Makes something'), function(){});
	
	установка используемого для отображения языка:
	config::setOutputLanguage('ru');

TODO: add parameters to \spectrum\run function:
	$paths/$files — for example, "/aaa.php", "/abc/*.php", "/abc/**.php", array("./aaa.php", "./abc/*.php") 
	$specId — for example, spec1_1_1
	$runInAllContexts = false
	??? $disableOutputBuffers — while (ob_get_level()){ ob_end_flush(); }
	$showFileNameAsGroup
	$fileNameAsGroupType = linear (all files as root groups), hierarchical (each file group as child of folder group) 

TODO: add "run this test in this context" and "run this test in all contexts" links to "Reports"

TODO: создать функцию для автоматической генерации контекстов во всевозможных комбинациях на основе множества значений (предполагаемые названия функции: combine, generateContexts; в "\spectrum\tools\*" или в "\spectrum\*")
TODO: create \spectrum\tools\createTree function and similar auxiliary functions and classes?
TODO: create \spectrum\tools\validateHtml('strict') or be('')->validHtml('strict|http://...')
TODO: create \spectrum\tools\validateXml('xhtml') or be('')->validXml('xhtml|http://...')
TODO: create $mock = new \spectrum\tools\Mock(new Spec); $mock->__calls; $mock->__sets; $mock->__gets;



=== Multi-charset support problems ===

group(function(){
	before(function(){ $this->aaa = 'text in utf-8'; });
	group(function(){
		before(function(){ $this->bbb = 'text in cp1251'; });
		test(function(){
			// What is result must be added to Results (true or false)?
			// How to detect correct charset for output and compare variables?
			be($this->aaa)->eq($this->bbb);
		});
	}, 'cp1251');
}, 'utf-8');

group(function(){
	before(function(){ $this->aaa = 'text in utf-8'; });
	test(function(){
		message($this->aaa); // Now message contains utf-8 text, but test charset is set to cp1251
		message('aaa is: ' . $this->aaa); // Now message contains incorrect string (in mixed charsets)
	}, 'cp1251');
}, 'utf-8');

group(function(){
	before(function(){ \projectName\SomeClass::setText('text in utf-8'); });
	test(function(){
		// What behaviour is expected?
		if (\projectName\SomeClass::getText() != 'text in cp1251')
			fail();
	}, 'cp1251');
}, 'utf-8');

group(function(){
	addMatcher('something', function($text){
		return in_array($text, array('text in utf-8', 'text in utf-8', 'text in utf-8'));
	});
	test(function(){
		// What result is expected (true or false)?
		// Pass charset to matcher function (and to "before/after" functions by analogy)? 
		be('text in cp1251')->something();
	}, 'cp1251');
}, 'utf-8');

group(function(){
	addMatcher('matcherNameInUtf8', function(){});
	test(function(){
		be()->matcherNameInCp1251(); // Is matcher call handling (in "Assertion" class) need converting for matcher name?
	}, 'cp1251');
}, 'utf-8');

TODO: add limited multi-charset support (with using input charset of each test/group for output/etc. and without using input charset for inner string transformation)???