TODO: getRootSpec -> getRootSpecOrSelf ???
TODO: улалить getRootSpec, проверя все корни в handleModifyDeny ??? но getRootSpecs не возвращает себя
TODO: переписать getRootSpecs в итеративном стиле (важен ли порядок) ???

TODO: array context group:
	group('aaa', array(
		'Номер мегафон' => array('code' => '495', 'phone' => '35861923'),
		'group: Межгород' => array(
			'Номер мегафон' => array('code' => '495', 'phone' => '35861923'),
			'Номер МТС' => array('code' => '495', 'phone' => '35861923'),
		),
	), function(){
		test('bbb', function(){});
	});

TODO: contexts\ContextData -> contexts\Data
TODO: тесты для constructionCommands
TODO: тесты для "\spectrum\matchers\*"

TODO: Spec::setName() — приводиль ли имя к строковому типу?
TODO: plugin OutputCapture -> output to message, onEndingSpecExecuteBefore/After or onSpecRunStart/Finish

TODO: в config::lock() и в ResultBuffer::lock записывать в static переменную метода свойства класса, а затем, в __destruct методе проверять, отличаются ли текущие свойства объекта от свойств в lock()::static (выбрасывая исключения в случае отличия) ???

TODO: для получения исходного кода вызова утверждений добавить счётчик вызовов матчеров на строках 
TODO: config::setCodeParserClass, config::setHighlightCodeFormatterClass
TODO: HighlightCodeFormatter->CodeFormatter|CodeHighlight|CodeDecorator

TODO: удалить verifications и verify из виджетов
TODO: reports->getOutputType, getIndention, getNewline => get...ThroughRunningAncestors
TODO: reports — по умолчанию не разворачивать список ошибок
TODO: success ("has empty" or "success, has empty")
TODO: реализовать проверку *RECURSION* в VariableHierarchical (в элементе массива тоже может содержаться объект)
TODO: вернуть отображение trace в оъектах exception, сделав сворачивание списка/разворачивание элементов дерева
TODO: DetailsControl — изменять state глобально - для всех экземпляров на странице. По умолчанию — state3
TODO: сдвинуть вывод буфера результатов за линию окончания номера узла
TODO: плагин "Report": report->highlightSpecNameWithSameFileName
TODO: рядом с результатом (серым шрифтом) и в верхнем и нижнем блоке писать кол-во выполненных тестов, время выполнения каждого теста и группы тестов (время выполнения группы вычислять либо путём сложения времени детей либо замерять реальное время выполнения либо писать оба значения либо одно значение писать в title)
TODO: добавить всплывающие подсказки с разъяснениями к элементам ползунка "Details"
TODO: плагин "Report": добавить title к резальтату или выводить "success", если есть "success" и "empty" дети
		empty title — "empty or has empty", "all or one of children was empty"
		all specs is "success"
		one or more specs is "fail"
		one or more specs is "empty" and has no "fail"

TODO: тесты для плагина "Reports"
TODO: "Reports" test "testGeneratesValidXhtml" (проверяет валидность вёрстки)

TODO: переименовать beforeEach/afterEach в before/after ???
TODO: rename ContextData to Context/ContextScope/etc. ???
TODO: rename contexts->add to addFunction/addApplierFunction/addContextApplier ???
TODO: rename setCatchPhpErrors to setPhpErrorLevel ???
TODO: choose exception naming style: BreakException vs ExceptionBreak
TODO: rename activateMoment to activateType/activationType ???
TODO: ResultBuffer: rename $result['result'] to $result['value/flag'] ???

TODO: put license text to each file head, remove LICENSE.txt, add to README.md note "Project is licensed under New BSD License (see license text in each file)"
TODO: проверить методы интерфейсов на соответствие методам класса и наоборот
TODO: написать doc комментарии к методам
TODO: проработать тексты сообщений в исключениях (возможно, привести к единому формату вида "function/method name: message"), проверить их грамотность

TO MAN: значения порядка вызова событий от -100 до 100 используются при регистрации базовых плагинов
TO MAN: на главной закрепить образец использования:
test('ожидаемый результат', function(){
	// код для проверки ожидаемого результата
}) 

TODO: добавить возможность перевода??? Пример: 
test('Makes something', function(){}, function(){
	// ...
	// ...
	// ...
	// ...
	// ...
}, array(
	'translations/langs' => array(
		'ru' => 'Делает что-либо',
	)
));

или:
translate('Делает что-либо', 'ru');
it('Makes something'), function(){});

установка используемого для отображения языка:
$spec->output/translate->setLanguage('ru');

TODO: создать функцию для автоматической генерации контекстов во всевозможных комбинациях на основе множества значений (предполагаемые названия функции: combine, generate)
TODO: плагин "Report": добавить возможность параллельного сохранения отчёта в файл (report->setWriteToFile())
TODO: run.php
	сделать run.php
	run.php?path=qwe.php&id=spec1_1_1
	возможность указывать путь к файлу или к папке, а так же несколько таких путей

TODO: плагин "Report": добавить ссылку "выполнить только этот тест" — в текущем контексте, во всех контекстах

TODO: assert, счетчик вызовов
Command::expectCount();
incrementCount()
count(getRunningInstance()->getResultStack())

--- mock
Spy
FileSystemMockReal
FileSystemMockVirtual

--- output:
	Вопрос: if ($spec->getName() == $name) — перекодировать надо или лучше хранить данные внутри обьектов в UTF-8?
	Ответ:
		Нет, т.к. тогда надо будет перекодировать данные в:
			Spec->setName(),
			SpecContainerPattern->setArguments(),
			SpecContainerPattern->getArguments() — при передаче callback функции в itLikePattern()
			SpecItemIt->setTestCallbackArguments(),
			SpecItemIt->getTestCallbackArguments() — при передаче testCallback функции
		Плюс плагины будут видеть данные world в исходной кодировке, т.к. полностью (включая данные их возможных в нем
		методов) перекодировать его будет проблематично.

		И если внутри кода тестов, написанного в одной кодировке будет вызван один из этих методов, то ему придется
		знать о том, что созданные им данные хранятся в обьектной структуре в другой кодировке и перекодировать.

		Вывод: оставляем хранение данных в обьектной структуре в исходной кодировке, отдавая таким образом предпочтение
		более прозрачной работе с кодировками из тестов, нежели из дополнительных обработчиков вне кода тестов (плагинов,
		кода обработки в runner'е и т.п.)

TODO: создать дополнительные матчеры??? Список:
spectrum_DefaultMatchers_Base_BePhpError(level)

spectrum_DefaultMatchers_File_BeFileExists
spectrum_DefaultMatchers_File_BeFileContentEqual
spectrum_DefaultMatchers_File_BeFileIsDir
spectrum_DefaultMatchers_File_BeFileIsFile
spectrum_DefaultMatchers_File_BeFileIsLink
spectrum_DefaultMatchers_File_BeFileIsExecutable
spectrum_DefaultMatchers_File_BeFileIsReadable
spectrum_DefaultMatchers_File_BeFileIsUploaded
spectrum_DefaultMatchers_File_BeFileIsWritable

spectrum_DefaultMatchers_Array_BeArrayHasKey
spectrum_DefaultMatchers_Array_BeArrayHasValue
spectrum_DefaultMatchers_Array_BeArrayHasAllKeys
spectrum_DefaultMatchers_Array_BeArrayHasAllValues
spectrum_DefaultMatchers_Array_BeArrayHasAnyKey
spectrum_DefaultMatchers_Array_BeArrayHasAnyValue
spectrum_DefaultMatchers_Array_BeArrayUnsortedEqual
spectrum_DefaultMatchers_Array_BeArrayUnsortedEqualRecursive
spectrum_DefaultMatchers_Array_BeArrayUnsortedIdentical
spectrum_DefaultMatchers_Array_BeArrayUnsortedIdenticalRecursive
spectrum_DefaultMatchers_Array_BeArrayCountEqual

spectrum_DefaultMatchers_String_BeStringContain
spectrum_DefaultMatchers_String_BeStringContainInPosition
spectrum_DefaultMatchers_String_BeStringStartWith
spectrum_DefaultMatchers_String_BeStringEndWith
spectrum_DefaultMatchers_File_BeStringEndWithAnySlash
spectrum_DefaultMatchers_File_BeStringStartWithAnySlash

spectrum_DefaultMatchers_RegExp_BePregMatch

spectrum_DefaultMatchers_Xml_BeXmlWellFormed
spectrum_DefaultMatchers_Xml_BeXmlValid

spectrum_DefaultMatchers_Html_BeHtmlAttributeEqual
spectrum_DefaultMatchers_Html_BeHtmlContainTag
spectrum_DefaultMatchers_Html_BeHtmlCorrect
spectrum_DefaultMatchers_Html_BeHtmlWellFormed
spectrum_DefaultMatchers_Html_BeHtmlValid